{
  "classification": {
    "primaryType": "API/Library",
    "confidence": 0.95,
    "characteristics": [
      "Self-updating mechanism",
      "GitHub Releases integration",
      "Cross-platform binary replacement",
      "Semantic Versioning aware"
    ],
    "adaptations": [
      "Designed for Command-line Tools",
      "Can be integrated into Desktop Applications"
    ]
  },
  "introduction": "The `ghupdate` library provides a robust and flexible solution for Go applications to self-update directly from GitHub releases. It streamlines the process of checking for newer versions, downloading the correct binary for the user's operating system and architecture, and performing an atomic, in-place replacement of the currently running executable.\n\nThis library is built for resilience, managing temporary files, gracefully handling error conditions, and seamlessly integrating into your application's startup flow, offering a truly hands-off update experience for your users.",
  "sections": [
    {
      "title": "Getting Started",
      "path": "getting-started.md",
      "content": "### Overview and Core Concepts\n\n`ghupdate` simplifies the distribution and maintenance of your Go applications by enabling them to update themselves. The core idea is a 'spawn-and-replace' mechanism:\n\n1.  **Preparation**: Your application checks GitHub for a newer version and downloads the new executable to a temporary location.\n2.  **Application**: When an update is ready, your running application *launches the newly downloaded executable* as a child process.\n3.  **Replacement**: The *new* executable (the child process) then waits for the *original* parent process to exit, and once the original executable's file lock is released, the new executable copies itself over the old one, becoming the new active version.\n4.  **Resumption**: The new executable then continues its `main` function, now running from the original path as the updated application.\n\nThis sequence ensures an atomic and robust update without requiring elevated privileges for the replacement itself in most common user-writable scenarios.\n\n### Quick Setup Guide\n\nTo integrate `ghupdate` into your Go project:\n\n1.  **Install the library**:\n\n    ```bash\n    go get github.com/asaidimu/ghupdate\n    ```\n\n2.  **Define application constants**:\n\n    ```go\n    // In your main package, define constants for your GitHub repo and app details\n    const (\n    \tgithubOwner    = \"your-github-owner\"\n    \tgithubRepo     = \"your-repo-name\"\n    \tassetPattern   = \"your-app-name-{version}-{os}-{arch}{ext}\" // Must match your release asset naming\n    \tappName        = \"your-app-name\"\n    )\n\n    // Version should be dynamically set at build time (e.g., via ldflags)\n    var Version = \"dev\" // Placeholder, will be replaced by build process\n    ```\n\n3.  **Implement the core update flow in `main()`**:\n\n    ```go\n    package main\n\n    import (\n    \t\"fmt\"\n    \t\"log\"\n    \t\"os\"\n    \t\"path/filepath\"\n    \t\"time\"\n\n    \t\"github.com/asaidimu/ghupdate\"\n    )\n\n    // ... (constants and Version variable as above)\n\n    func main() {\n    \t// Step 1: Crucially, handle update mode first.\n    \t// If this returns true, the app was just updated and is now running the new version.\n    \tif ghupdate.HandleUpdateMode() {\n    \t\tfmt.Println(\"ðŸŽ‰ Successfully updated! Resuming normal operation.\")\n    \t}\n\n    \t// Determine a cross-platform data directory for temporary files.\n    \tdataDir, err := getAppDataDir(appName)\n    \tif err != nil {\n    \t\tlog.Fatalf(\"Error determining application data directory: %v\", err)\n    \t}\n\n    \t// Step 2: Clean up any leftover temporary update files.\n    \tif err := ghupdate.CleanupUpdate(dataDir); err != nil {\n    \t\tlog.Printf(\"Warning: Failed to clean up old update files: %v\\n\", err)\n    \t}\n\n    \t// Step 3: Your application's normal logic goes here.\n    \tfmt.Printf(\"%s - Version %s\\n\", appName, Version)\n    \tfmt.Println(\"Running application logic...\")\n    \ttime.Sleep(2 * time.Second)\n\n    \t// Step 4: Periodically check for and apply updates.\n    \tcheckUpdates(dataDir) // Or trigger via user command/goroutine\n\n    \tfmt.Println(\"Application finished.\")\n    }\n\n    // Helper to get a cross-platform temporary data directory\n    func getAppDataDir(appName string) (string, error) {\n    \tdir, err := os.UserCacheDir()\n    \tif err != nil {\n    \t\tdir, err = os.UserConfigDir() // Fallback\n    \t\tif err != nil {\n    \t\t\treturn \"\", fmt.Errorf(\"could not determine user cache or config directory: %w\", err)\n    \t\t}\n    \t}\n    \tappDataDir := filepath.Join(dir, appName)\n    \tif err := os.MkdirAll(appDataDir, 0755); err != nil {\n    \t\treturn \"\", fmt.Errorf(\"failed to create application data directory %q: %w\", appDataDir, err)\n    \t}\n    \treturn appDataDir, nil\n    }\n\n    // Function to encapsulate the update check logic\n    func checkUpdates(dataDir string) {\n    \tfmt.Println(\"\\nChecking for updates...\")\n\n    \texecutablePath, err := os.Executable()\n    \tif err != nil {\n    \t\tlog.Printf(\"Error getting executable path: %v\", err)\n    \t\treturn\n    \t}\n\n    \tconfig := ghupdate.UpdateConfig{\n    \t\tGitHubOwner:    githubOwner,\n    \t\tGitHubRepo:     githubRepo,\n    \t\tGitHubToken:    os.Getenv(\"GITHUB_TOKEN\"), // Optional: For private repos or rate limits\n    \t\tCurrentVersion: Version,\n    \t\tDataDir:        dataDir,\n    \t\tExecutablePath: executablePath,\n    \t\tAssetPattern:   assetPattern,\n    \t}\n\n    \tupdateInfo, err := ghupdate.CheckAndPrepareUpdate(config)\n    \tif err != nil {\n    \t\tlog.Printf(\"Error checking for update: %v\\n\", err)\n    \t\treturn\n    \t}\n\n    \tif updateInfo == nil {\n    \t\tfmt.Println(\"No update available. You are on the latest version.\")\n    \t\treturn\n    \t}\n\n    \tfmt.Printf(\"Update available! Current: %s, Latest: %s\\n\", updateInfo.CurrentVersion, updateInfo.LatestVersion)\n    \tfmt.Printf(\"Release Notes:\\n%s\\n\", updateInfo.ReleaseNotes)\n\n    \tfmt.Println(\"Applying update...\")\n    \terr = ghupdate.ApplyUpdate(config)\n    \tif err != nil {\n    \t\tlog.Fatalf(\"Error applying update: %v\\n\", err)\n    \t}\n    \t// If ApplyUpdate succeeds, the program exits here.\n    \t// The new executable has taken over.\n    }\n    ```\n\n### First Tasks with Decision Patterns\n\n**Task 1: Initialize the Update System at Application Startup**\n\n- **Goal**: Ensure the application can handle an incoming update and prepare for future checks.\n- **Decision Pattern**: IF application is launching THEN call `HandleUpdateMode()` first to check if it's an update process, then call `CleanupUpdate()` to clear old temporary files. THEN proceed with normal application logic.\n- **Expected Outcome**: Application starts cleanly, able to self-update.\n",
      "agentGuidance": {
        "decisionPoints": [
          "IF application_startup THEN call method:HandleUpdateMode AND call method:CleanupUpdate",
          "IF method:HandleUpdateMode returns true THEN log \"Update successful\" AND proceed_with_new_executable",
          "IF method:HandleUpdateMode returns false THEN continue_with_normal_startup_logic"
        ],
        "verificationSteps": [
          "Check: `ghupdate.HandleUpdateMode()` is the first executable line in `main()`.",
          "Check: `ghupdate.CleanupUpdate(dataDir)` is called after `HandleUpdateMode()`.",
          "Check: `dataDir` is a user-writable path, preferably `os.UserCacheDir()`."
        ],
        "quickPatterns": [
          "Pattern: Go main function boilerplate\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\t\"github.com/asaidimu/ghupdate\"\n)\n\nvar Version = \"dev\"\nconst appName = \"my-app\"\nconst githubOwner = \"my-owner\"\nconst githubRepo = \"my-repo\"\nconst assetPattern = \"my-app-{version}-{os}-{arch}{ext}\"\n\nfunc main() {\n\tif ghupdate.HandleUpdateMode() {\n\t\tfmt.Println(\"Updated!\")\n\t}\n\n\tdataDir, err := os.UserCacheDir()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error: %v\", err)\n\t}\n\tdataDir = filepath.Join(dataDir, appName)\n\t_ = os.MkdirAll(dataDir, 0755) // Ensure dir exists\n\n\tif err := ghupdate.CleanupUpdate(dataDir); err != nil {\n\t\tlog.Printf(\"Cleanup warning: %v\\n\", err)\n\t}\n\n\tfmt.Printf(\"Running %s version %s\\n\", appName, Version)\n\n\t// Application's core logic here\n\n\tcheckUpdates(dataDir)\n}\n\nfunc checkUpdates(dataDir string) {\n\texecPath, _ := os.Executable()\n\tconfig := ghupdate.UpdateConfig{\n\t\tGitHubOwner: githubOwner,\n\t\tGitHubRepo: githubRepo,\n\t\tCurrentVersion: Version,\n\t\tDataDir: dataDir,\n\t\tExecutablePath: execPath,\n\t\tAssetPattern: assetPattern,\n\t}\n\tupdateInfo, err := ghupdate.CheckAndPrepareUpdate(config)\n\tif err != nil {\n\t\tlog.Printf(\"Update check error: %v\\n\", err)\n\t\treturn\n\t}\n\tif updateInfo != nil {\n\t\tfmt.Printf(\"Update available: %s -> %s\\n\", updateInfo.CurrentVersion, updateInfo.LatestVersion)\n\t\tif err := ghupdate.ApplyUpdate(config); err != nil {\n\t\t\tlog.Fatalf(\"Apply update error: %v\\n\", err)\n\t\t}\n\t}\n}\n```"
        ],
        "diagnosticPaths": [
          "Error: Application not updating -> Symptom: Old version keeps running after `ApplyUpdate` call -> Check: Is `ghupdate.HandleUpdateMode()` the very first function call in `main()`? -> Fix: Move `ghupdate.HandleUpdateMode()` to the top of `main()` before any other logic."
        ]
      }
    },
    {
      "title": "Core Operations",
      "path": "core-operations.md",
      "content": "### Essential Functions\n\nThe `ghupdate` library provides four primary functions that orchestrate the entire self-update process:\n\n*   [`ghupdate.HandleUpdateMode()`](#method:HandleUpdateMode): Called on application startup to perform the actual executable replacement if an update was initiated.\n*   [`ghupdate.CleanupUpdate(dataDir string)`](#method:CleanupUpdate): Removes temporary update files.\n*   [`ghupdate.CheckAndPrepareUpdate(config UpdateConfig)`](#method:CheckAndPrepareUpdate): Checks for new releases on GitHub, downloads the correct asset, and prepares it for application.\n*   [`ghupdate.ApplyUpdate(config UpdateConfig)`](#method:ApplyUpdate): Triggers the replacement process by spawning the newly downloaded executable.\n\n### Workflows with Decision Trees\n\nThe typical workflow for integrating `ghupdate` is a sequence of calls that ensure robustness and atomicity.\n\n#### Application Startup Flow\n\nThis workflow describes the critical steps your application should take immediately upon starting.\n\n1.  **Check for Update Mode**: The application first determines if it was launched as part of an update process (`ghupdate.HandleUpdateMode`). If it was, it performs the file replacement and then continues execution as the newly updated application.\n2.  **Clean Temporary Files**: Regardless of update mode, temporary files from previous update attempts are cleaned up (`ghupdate.CleanupUpdate`).\n3.  **Normal Application Logic**: The application proceeds with its intended functionality.\n\n#### Update Initiation Flow\n\nThis workflow describes how your application proactively checks for and applies updates.\n\n1.  **Check for New Version**: The application queries GitHub for the latest release and compares it against its current version (`ghupdate.CheckAndPrepareUpdate`). If a newer version is found, the asset is downloaded.\n2.  **Apply Update**: If an update is prepared, the application initiates the replacement (`ghupdate.ApplyUpdate`), which causes the current process to exit and the newly downloaded executable to take over.\n\n",
      "agentGuidance": {
        "decisionPoints": [
          "IF ghupdate.HandleUpdateMode returns true THEN log \"Update applied, resuming\" AND proceed with updated application flow",
          "IF ghupdate.HandleUpdateMode returns false THEN proceed to ghupdate.CleanupUpdate(dataDir)",
          "IF ghupdate.CleanupUpdate(dataDir) returns error THEN log \"Cleanup warning\" AND continue",
          "IF ghupdate.CheckAndPrepareUpdate(config) returns nil (no updateInfo) AND nil (error) THEN log \"No update available\" AND continue_normal_app_flow",
          "IF ghupdate.CheckAndPrepareUpdate(config) returns updateInfo AND nil (error) THEN log \"Update available\" AND call ghupdate.ApplyUpdate(config)",
          "IF ghupdate.CheckAndPrepareUpdate(config) returns nil AND error THEN log \"Error checking for update\" AND continue_normal_app_flow",
          "IF ghupdate.ApplyUpdate(config) returns error THEN log \"Error applying update\" AND exit_with_failure"
        ],
        "verificationSteps": [
          "Check: `ghupdate.HandleUpdateMode()` is always executed first.",
          "Check: `ghupdate.CleanupUpdate()` is called once per application launch.",
          "Check: `ghupdate.CheckAndPrepareUpdate()` is called periodically or on demand.",
          "Check: `ghupdate.ApplyUpdate()` is only called if `CheckAndPrepareUpdate()` returns a valid `UpdateInfo`."
        ],
        "quickPatterns": [
          "Pattern: Full update cycle within application\n```go\nfunc main() {\n\tif ghupdate.HandleUpdateMode() {\n\t\tfmt.Println(\"Update complete.\")\n\t\t// New version is running, continue normal operations.\n\t}\n\n\tdataDir, _ := os.UserCacheDir()\n\tdataDir = filepath.Join(dataDir, \"my-app\")\n\t_ = os.MkdirAll(dataDir, 0755)\n\n\tif err := ghupdate.CleanupUpdate(dataDir); err != nil {\n\t\tlog.Printf(\"Cleanup warning: %v\\n\", err)\n\t}\n\n\t// Core application logic...\n\n\texecPath, _ := os.Executable()\n\tconfig := ghupdate.UpdateConfig{\n\t\tGitHubOwner:    \"owner\",\n\t\tGitHubRepo:     \"repo\",\n\t\tCurrentVersion: \"v1.0.0\",\n\t\tDataDir:        dataDir,\n\t\tExecutablePath: execPath,\n\t\tAssetPattern:   \"my-app-{version}-{os}-{arch}{ext}\",\n\t}\n\n\tupdateInfo, err := ghupdate.CheckAndPrepareUpdate(config)\n\tif err != nil {\n\t\tlog.Printf(\"Error checking update: %v\", err)\n\t} else if updateInfo != nil {\n\t\tfmt.Printf(\"Update found: %s -> %s\\n\", updateInfo.CurrentVersion, updateInfo.LatestVersion)\n\t\t// Notify user, then apply.\n\t\tif err := ghupdate.ApplyUpdate(config); err != nil {\n\t\t\tlog.Fatalf(\"Error applying update: %v\", err)\n\t\t}\n\t\t// This line is not reached on success.\n\t}\n}\n```"
        ],
        "diagnosticPaths": [
          "Error: `CheckAndPrepareUpdate` fails with \"failed to fetch latest release\" -> Symptom: Network error, invalid GitHubOwner/GitHubRepo, or GitHub API rate limit -> Check: Verify internet connectivity, check `GitHubOwner` and `GitHubRepo` names, ensure `GITHUB_TOKEN` is set for private repos or to avoid rate limits. -> Fix: Correct configuration, set `GITHUB_TOKEN` environment variable.",
          "Error: `CheckAndPrepareUpdate` fails with \"no asset found matching pattern\" -> Symptom: Downloaded asset name does not match expected pattern -> Check: Compare `AssetPattern` with actual GitHub release asset names, including `{version}`, `{os}`, `{arch}`, `{ext}` placeholders. Ensure release is not a draft or pre-release unless intended. -> Fix: Adjust `AssetPattern` to exactly match your release binaries."
        ]
      }
    },
    {
      "title": "Task-Based Guide",
      "path": "task-based-guide.md",
      "content": "### 1. Integrating Self-Updates into a Go CLI Application\n\nThis is the primary use case for `ghupdate`. The key is to embed the update logic directly into your application's `main` function.\n\n**Steps:**\n\n1.  **Define build-time variables**: Use `go build -ldflags \"-X main.Version=$(VERSION)\"` to inject your application's current version dynamically.\n2.  **Call `HandleUpdateMode()` early**: This is critical for the in-place replacement mechanism.\n3.  **Clean up old update files**: Use `CleanupUpdate()` to maintain a tidy system.\n4.  **Periodically check for updates**: Decide when to call `CheckAndPrepareUpdate()` (e.g., on startup, hourly, or via a `--check-update` command-line flag).\n5.  **Apply updates conditionally**: Only call `ApplyUpdate()` if `CheckAndPrepareUpdate()` indicates a new version is available.\n\n**Example (see Getting Started section for full code)**\n\n```go\nfunc main() {\n\tif ghupdate.HandleUpdateMode() {\n\t\t// The app just updated, new binary is running.\n\t}\n\n\tdataDir, _ := getAppDataDir(appName)\n\t_ = ghupdate.CleanupUpdate(dataDir)\n\n\t// Your application's main logic\n\n\tcheckUpdates(dataDir) // Initiate update check\n}\n```\n\n### 2. Configuring Update Parameters\n\nThe `ghupdate.UpdateConfig` struct dictates how `ghupdate` behaves. Proper configuration is vital for success.\n\n**Key fields to configure:**\n\n*   `GitHubOwner` & `GitHubRepo`: Point to your GitHub repository.\n*   `CurrentVersion`: Should match your application's current semantic version (e.g., `v1.2.3`).\n*   `DataDir`: A user-writable directory for temporary files (e.g., `os.UserCacheDir()`).\n*   `ExecutablePath`: The full path to the currently running executable (`os.Executable()`).\n*   `AssetPattern`: Matches the naming convention of your release binaries.\n\n**Considerations:**\n\n*   For public repositories, `GitHubToken` is optional but recommended to avoid rate limiting.\n*   For private repositories, `GitHubToken` is mandatory and requires appropriate scope (e.g., `repo`).\n*   `OS` and `Arch` can be left empty to default to `runtime.GOOS` and `runtime.GOARCH`.\n\n### 3. Handling GitHub Authentication\n\nTo interact with private GitHub repositories or to increase API rate limits for public ones, provide a GitHub Personal Access Token (PAT).\n\n**Steps:**\n\n1.  **Generate a PAT**: Go to GitHub -> Settings -> Developer settings -> Personal access tokens. Grant `repo` scope for private repos, or `public_repo` for public ones.\n2.  **Store the PAT securely**: Do **not** hardcode it in your source code. Use environment variables.\n3.  **Pass to `UpdateConfig`**: Retrieve the token from the environment variable and assign it to `config.GitHubToken`.\n\n**Example:**\n\n```go\nconfig := ghupdate.UpdateConfig{\n\t// ... other fields\n\tGitHubToken: os.Getenv(\"GITHUB_TOKEN\"), // Reads from GITHUB_TOKEN environment variable\n\t// ...\n}\n```\n\n### 4. Releasing and Versioning Best Practices\n\nEffective release management is crucial for a smooth update experience.\n\n*   **Semantic Versioning**: Always tag your GitHub releases with semantic versions (e.g., `v1.0.0`, `v1.0.1`, `v2.0.0`). `ghupdate` relies on `golang.org/x/mod/semver` for comparisons.\n*   **Dynamic Version Injection**: Inject `CurrentVersion` into your Go binary at build time using `-ldflags`. This prevents discrepancies between your code and the actual binary version.\n\n    ```bash\n    # Example Makefile snippet for building:\n    VERSION := $(shell git describe --tags --abbrev=0 --always)\n    BUILD_DATE := $(shell date -u +'%Y-%m-%dT%H:%M:%SZ')\n\n    build:\n    \tgo build -ldflags \"-X main.Version=$(VERSION) -X main.BuildDate=$(BUILD_DATE)\" -o dist/my-app ./main.go\n    ```\n*   **Consistent Asset Naming**: Ensure your release assets uploaded to GitHub consistently follow the pattern you define in `AssetPattern`.\n\n    *Correct*: `my-app-v1.0.0-linux-amd64`, `my-app-v1.0.0-windows-amd64.exe`\n    *Incorrect*: `my-app_linux_amd64`, `myapp.zip` (if `AssetPattern` expects `myapp-{version}-{os}-{arch}{ext}`)\n",
      "agentGuidance": {
        "decisionPoints": [
          "IF requiring_authenticated_github_access THEN set_environment_variable GITHUB_TOKEN",
          "IF using_semantic_release_for_versioning THEN configure_ldflags_to_inject_version",
          "IF releasing_new_application_version THEN ensure_release_asset_names_match_AssetPattern"
        ],
        "verificationSteps": [
          "Check: `CurrentVersion` in `UpdateConfig` matches the version embedded in the binary.",
          "Check: Release asset names on GitHub correspond exactly to `AssetPattern`.",
          "Check: `GITHUB_TOKEN` environment variable is set if private repo or rate limit is a concern."
        ],
        "quickPatterns": [
          "Pattern: Go ldflags for version injection\n```bash\ngo build -ldflags \"-X 'main.Version=$(git describe --tags --abbrev=0)'\" -o myapp .\n```",
          "Pattern: Configuring `UpdateConfig` for private repo\n```go\nconfig := ghupdate.UpdateConfig{\n\tGitHubOwner:    \"myorg\",\n\tGitHubRepo:     \"my-private-app\",\n\tGitHubToken:    os.Getenv(\"GITHUB_TOKEN\"), // Must be set in env\n\tCurrentVersion: Version,\n\tDataDir:        dataDir,\n\tExecutablePath: executablePath,\n\tAssetPattern:   \"my-private-app-{version}-{os}-{arch}{ext}\",\n}\n```"
        ],
        "diagnosticPaths": [
          "Error: `CurrentVersion` in `UpdateInfo` is 'dev' or wrong -> Symptom: Application does not report correct version, or updates don't trigger when they should -> Check: Verify `ldflags` in your build script. Ensure `main.Version` variable is correctly targeted. -> Fix: Correct `ldflags` to embed the actual version string.",
          "Error: `fetchLatestRelease` returns 403 Forbidden -> Symptom: Cannot access private repository or hit rate limit -> Check: Ensure `GITHUB_TOKEN` is set in environment and passed to `UpdateConfig`. For private repos, confirm PAT has `repo` scope. -> Fix: Generate new PAT with correct permissions, or set existing PAT environment variable."
        ]
      }
    },
    {
      "title": "Advanced Usage",
      "path": "advanced-usage.md",
      "content": "### Complex Scenarios and Customization\n\n#### Customizing Asset Patterns\n\nThe `AssetPattern` field in `UpdateConfig` is highly flexible. It allows you to match arbitrary asset naming conventions on your GitHub releases.\n\n*   `{version}`: The release tag name (e.g., `v1.2.3`).\n*   `{os}`: The target operating system (`windows`, `linux`, `darwin`).\n*   `{arch}`: The target architecture (`amd64`, `arm64`, `386`).\n*   `{ext}`: The executable extension (`.exe` on Windows, empty string otherwise).\n\n**Examples:**\n\n| Your Asset Name              | `AssetPattern`                                  |\n| :--------------------------- | :---------------------------------------------- |\n| `mycli-v1.0.0-linux-amd64`   | `mycli-{version}-{os}-{arch}`                   |\n| `app_1.2.3_macOS_arm64.zip`  | `app_{version}_macOS_{arch}.zip`                |\n| `server-v2.0.0-windows.exe`  | `server-{version}-{os}{ext}` (if arch omitted)  |\n\nEnsure your Go build process names the binaries exactly to match your pattern.\n\n#### Cross-Platform Considerations\n\n`ghupdate` automatically detects the current operating system (`runtime.GOOS`) and architecture (`runtime.GOARCH`). However, you can override these values in `UpdateConfig` if you need to download an asset for a *different* platform (e.g., an admin downloading a Windows executable from a Linux machine).\n\n```go\nconfig := ghupdate.UpdateConfig{\n\t// ... other fields\n\tOS:   \"darwin\", // Forces download for macOS\n\tArch: \"arm64\",  // Forces download for ARM64 architecture\n}\n```\n\n#### Optimization: Update Frequency\n\nAvoid checking for updates too frequently. Excessive API calls can lead to GitHub rate limiting. Good strategies include:\n\n*   **On Application Startup**: A single check when the application first launches.\n*   **Time-Based**: Every 24 hours, or only after a certain period of application uptime.\n*   **User-Initiated**: Provide a command-line flag (e.g., `--update`) or a menu option in a GUI application for users to manually trigger an update check.\n\n### Optimization: Build Configuration\n\nEnsure your Go build produces correctly named and permissioned binaries.\n\n*   **Permissions**: On Unix-like systems, downloaded binaries need executable permissions. `ghupdate` automatically handles `os.Chmod(updatePath, 0755)`.\n*   **Deterministic Builds**: For robust updates, ensure your build process is deterministic, so the same source code always produces the same binary for a given version.",
      "agentGuidance": {
        "decisionPoints": [
          "IF asset_name_is_complex THEN construct_AssetPattern_using_placeholders {version}, {os}, {arch}, {ext}",
          "IF cross_platform_download_needed THEN override_config_OS_and_config_Arch",
          "IF managing_github_api_rate_limits THEN implement_update_checks_periodically_or_on_demand"
        ],
        "verificationSteps": [
          "Check: Test `AssetPattern` by manually constructing the expected name and verifying it exists on GitHub.",
          "Check: For cross-platform downloads, verify the downloaded asset's properties match the specified `OS` and `Arch`.",
          "Check: Monitor GitHub API usage if frequent checks are implemented."
        ],
        "quickPatterns": [
          "Pattern: Overriding OS/Arch for `UpdateConfig`\n```go\nconfig := ghupdate.UpdateConfig{\n\t// ...\n\tOS:   \"windows\", // Target Windows\n\tArch: \"amd64\",   // Target AMD64\n}\n```"
        ],
        "diagnosticPaths": [
          "Error: Update fails, but no specific error from `ghupdate` functions -> Symptom: Application restarts to old version or crashes silently during update -> Check: Verify the build process for your release assets. Is the asset truly executable? Does it match the expected OS/arch? -> Fix: Rebuild release asset, test local execution, verify `file` command output (on Unix) or properties (on Windows)."
        ]
      }
    },
    {
      "title": "Problem Solving",
      "path": "problem-solving.md",
      "content": "### Troubleshooting Common Issues\n\nThis section addresses common problems encountered when integrating and using `ghupdate`.\n\n#### 1. \"Error checking for update: failed to find matching asset\"\n\n*   **Cause**: The `AssetPattern` in your `UpdateConfig` does not accurately describe the file names of the assets in your GitHub release. This is the most common issue.\n*   **Diagnosis**: \n    1.  Go to your GitHub release page and note the exact file names of your binaries (e.g., `mycli-v1.0.0-linux-amd64`, `mycli-v1.0.0-windows-amd64.exe`).\n    2.  Compare these names against the pattern you provided in `config.AssetPattern`. Remember `ghupdate` replaces `{version}`, `{os}`, `{arch}`, `{ext}` placeholders.\n    3.  Ensure the release is *not* a `draft` or `prerelease` (unless you're using a custom GitHub API call to fetch those, which `ghupdate` doesn't do by default for `releases/latest`).\n*   **Solution**: Adjust your `AssetPattern` to precisely match the naming convention of your uploaded release assets. For example, if your asset is named `my-app-v1.2.3-linux-amd64`, your pattern should be `my-app-{version}-{os}-{arch}`.\n\n#### 2. \"GitHub API returned status 403\" or \"API rate limit exceeded\"\n\n*   **Cause**: You have hit GitHub's API rate limits (for unauthenticated requests, typically 60 requests per hour), or you are trying to access a private repository without providing a valid `GitHubToken`.\n*   **Diagnosis**: \n    1.  Check if you're making too many requests (e.g., checking for updates on every application launch for many users).\n    2.  Verify if `os.Getenv(\"GITHUB_TOKEN\")` is returning an empty string when it shouldn't be.\n    3.  If accessing a private repository, ensure your GitHub PAT has the `repo` scope enabled.\n*   **Solution**: \n    1.  Provide a `GitHubToken` in your `UpdateConfig`. It's good practice even for public repositories to increase the rate limit to 5000 requests per hour.\n    2.  Adjust your update check frequency to be less aggressive (e.g., once a day, or on user command).\n\n#### 3. \"Permission denied\" during `ApplyUpdate` or `CleanupUpdate`\n\n*   **Cause**: The application lacks the necessary write permissions to the `DataDir` (for temporary files) or the `ExecutablePath` (for the final replacement).\n*   **Diagnosis**: \n    1.  Check the permissions of the directory specified in `config.DataDir`. This should typically be a user-writable location like `os.UserCacheDir()` or `os.UserConfigDir()`.\n    2.  Check the permissions of the `ExecutablePath`. If your application is installed in a system-wide location (e.g., `/usr/local/bin` on Linux, `Program Files` on Windows), standard users might not have write permissions to overwrite the binary directly.\n*   **Solution**: \n    1.  Ensure `DataDir` is set to a user-writable location, such as one returned by `os.UserCacheDir()`.\n    2.  If the application is installed in a privileged location, consider deploying updates through a system package manager or an installer that handles privilege elevation, as `ghupdate` is primarily designed for user-writable locations. For CLI tools, encouraging users to install into `~/bin` or similar user-owned paths is common.\n\n#### 4. Application Doesn't Update, or `HandleUpdateMode()` Isn't Called\n\n*   **Cause**: The `ghupdate.HandleUpdateMode()` function is not being called as the *very first* executable statement in your `main` function, or the `ApplyUpdate` process failed to correctly spawn the new process with the required arguments.\n*   **Diagnosis**: \n    1.  Inspect your `main` function to confirm `if ghupdate.HandleUpdateMode() { ... }` is the first line of code.\n    2.  Check `ApplyUpdate`'s error logs (if any are returned) from the previous run to see if the new process failed to start.\n*   **Solution**: Always ensure `if ghupdate.HandleUpdateMode() { ... }` is the absolute first thing that happens in your `main()` function, even before any logging or path determination. `ApplyUpdate` is designed to be robust in spawning the new process; issues here usually point to fundamental system problems.",
      "agentGuidance": {
        "decisionPoints": [
          "IF error_is_about_missing_asset THEN check_AssetPattern_against_release_names",
          "IF error_is_403_or_rate_limit THEN check_GITHUB_TOKEN_and_update_frequency",
          "IF error_is_permission_denied THEN check_DataDir_and_ExecutablePath_permissions",
          "IF update_fails_silently THEN verify_HandleUpdateMode_position_in_main_function"
        ],
        "verificationSteps": [
          "Check: Manually download release asset and verify its name against generated pattern string.",
          "Check: Inspect `GITHUB_TOKEN` environment variable value in runtime environment.",
          "Check: Run `ls -ld <DataDir>` and `ls -l <ExecutablePath>` to inspect permissions.",
          "Check: Review source code of `main` function to ensure `ghupdate.HandleUpdateMode()` is the very first statement."
        ],
        "quickPatterns": [
          "Pattern: Debugging `AssetPattern`\n```go\n// In ghupdate source (for debugging), or temporarily in your app:\nfmt.Printf(\"Expected asset name: %s\\n\", buildAssetName(config.AssetPattern, release.TagName, targetOS, targetArch))\n// Compare this output with actual GitHub asset names.\n```"
        ],
        "diagnosticPaths": [
          "Error: \"failed to find matching asset\" -> Symptom: Application cannot locate release binary -> Check: Verify `AssetPattern` matches GitHub asset exact names. Check for typos in `GitHubOwner` or `GitHubRepo`. Ensure release is not a draft/prerelease. -> Fix: Adjust `AssetPattern` or release asset names. Confirm GitHub repository details.",
          "Error: `os.Executable()` fails or returns unexpected path -> Symptom: `ExecutablePath` is incorrect, causing update failure -> Check: Run `fmt.Println(os.Executable())` to confirm the path. -> Fix: Ensure application is launched in a standard manner, or adjust how `ExecutablePath` is determined if using unusual launch methods.",
          "Error: `log.Fatalf` on `ApplyUpdate` -> Symptom: Application immediately exits during update attempt -> Check: Verify that `CheckAndPrepareUpdate` successfully downloaded a file to `DataDir`. Is the downloaded file actually executable? -> Fix: Investigate `CheckAndPrepareUpdate` errors first, then ensure the downloaded asset is valid and executable for the target system."
        ]
      }
    }
  ],
  "reference": {
    "system": {
      "name": "ghupdate",
      "language": "Go",
      "description": "A Go library for enabling self-updating capabilities in command-line and desktop applications by integrating with GitHub Releases.",
      "keyFeatures": [
        "Automatic self-updating from GitHub",
        "Cross-platform binary replacement",
        "Semantic versioning comparison",
        "Atomic update mechanism",
        "Support for private repositories with GitHub PATs"
      ]
    },
    "dependencies": {
      "external": [
        {
          "name": "golang.org/x/mod/semver",
          "purpose": "Used for robust semantic version comparison (vX.Y.Z) to determine if a newer version is available.",
          "interfaces": [],
          "installation": "go get golang.org/x/mod/semver",
          "version": ">=0.0.0"
        }
      ],
      "peer": [
        {
          "name": "Go Runtime",
          "reason": "Required to compile and run `ghupdate` and applications using it.",
          "version": ">=1.24.4"
        }
      ]
    },
    "integration": {
      "environmentRequirements": "Go 1.24.4+ is required for compilation and runtime. Standard operating system environments (Linux, macOS, Windows) are supported. Write permissions are needed for the `DataDir` (temporary update files) and `ExecutablePath` (where the binary is located) to perform updates without elevated privileges. For `ExecutablePath`, this implies the application should be in a user-writable location.",
      "initializationPatterns": [
        {
          "description": "The primary initialization pattern involves calling `HandleUpdateMode()` first in your `main` function, followed by `CleanupUpdate()`, before any other application logic. This ensures correct handling of update-initiated restarts and a clean state.",
          "codeExample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/asaidimu/ghupdate\"\n)\n\nvar Version = \"v1.0.0\" // Injected at build time\n\nfunc main() {\n\t// IMPORTANT: This must be the very first executable line.\n\t// If true, the application was just updated and is now the new version.\n\tif ghupdate.HandleUpdateMode() {\n\t\tfmt.Println(\"Successfully updated! Running new version.\")\n\t}\n\n\t// Determine application data directory (e.g., for temporary update files).\n\tdataDir, err := os.UserCacheDir()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error getting cache dir: %v\", err)\n\t}\n\tappDataDir := filepath.Join(dataDir, \"my-app-name\")\n\tif err := os.MkdirAll(appDataDir, 0755); err != nil {\n\t\tlog.Fatalf(\"Error creating app data dir: %v\", err)\n\t}\n\n\t// Clean up any old temporary update files.\n\tif err := ghupdate.CleanupUpdate(appDataDir); err != nil {\n\t\tlog.Printf(\"Warning: Failed to clean up old update files: %v\\n\", err)\n\t}\n\n\t// Your application's main logic begins here.\n\tfmt.Printf(\"My Application - Version %s running from %s\\n\", Version, os.Args[0])\n\t// ... rest of your application ...\n}"
        }
      ],
      "commonPitfalls": [
        {
          "issue": "Not calling `ghupdate.HandleUpdateMode()` as the very first operation in `main()`.",
          "solution": "This is critical. If `HandleUpdateMode()` is not called first, the newly spawned executable will not perform the file replacement, and the old version will continue running, or the update will fail silently. Always place it at the absolute beginning of your `main` function."
        },
        {
          "issue": "Hardcoding `CurrentVersion` instead of injecting it at build time.",
          "solution": "Hardcoding makes releases cumbersome and prone to errors. Use Go's `-ldflags` to embed the version (e.g., from `git describe --tags`) directly into the binary during compilation. This ensures the application always knows its true version."
        },
        {
          "issue": "Incorrect `AssetPattern` or inconsistent GitHub release asset naming.",
          "solution": "`ghupdate` relies on an exact match between the `AssetPattern` and your uploaded GitHub release binary names. Double-check the pattern, including all placeholders (`{version}`, `{os}`, `{arch}`, `{ext}`), against the actual file names on your release page."
        }
      ],
      "lifecycleDependencies": "The `ghupdate` library expects to manage its lifecycle during application startup and during explicit update checks. `HandleUpdateMode()` must run at the very beginning to capture control when an update is being applied. `ApplyUpdate()` causes the current process to exit, transferring control to the newly spawned executable. Therefore, any resources or goroutines started *before* `ApplyUpdate()` is called will be terminated. Cleanup should be done during startup, not shutdown, to ensure temporary files from failed attempts are removed."
    },
    "types": {
      "UpdateConfig": {
        "id": "type:UpdateConfig",
        "definition": "type UpdateConfig struct {\n    GitHubOwner    string\n    GitHubRepo     string\n    GitHubToken    string\n    CurrentVersion string\n    DataDir        string\n    ExecutablePath string\n    AssetPattern   string\n    OS             string\n    Arch           string\n}",
        "purpose": "Holds all necessary configuration parameters for the self-update process, including GitHub repository details, current application version, and file paths for downloads and replacement.",
        "related": {
          "methods": [
            "method:CheckAndPrepareUpdate",
            "method:ApplyUpdate"
          ],
          "patterns": []
        },
        "interfaceContract": {
          "requiredMethods": [],
          "optionalMethods": [],
          "parameterObjectStructures": {
            "GitHubOwner": "string (e.g., \"asaidimu\") - The GitHub username or organization name.",
            "GitHubRepo": "string (e.g., \"ghupdate\") - The name of the GitHub repository.",
            "GitHubToken": "string (optional) - A GitHub personal access token for authentication and rate limit bypass.",
            "CurrentVersion": "string (e.g., \"v1.0.0\") - The semantic version of the running application. Must start with 'v' for `semver` comparison.",
            "DataDir": "string (absolute path) - A writable directory for temporary update files. `os.UserCacheDir()` is recommended.",
            "ExecutablePath": "string (absolute path) - The full path to the currently running executable. Use `os.Executable()`.",
            "AssetPattern": "string (e.g., \"my-app-{version}-{os}-{arch}{ext}\") - Pattern to match release assets. Supports `{version}`, `{os}`, `{arch}`, `{ext}` placeholders.",
            "OS": "string (optional, e.g., \"linux\", \"windows\", \"darwin\") - Target OS. If empty, `runtime.GOOS` is used.",
            "Arch": "string (optional, e.g., \"amd64\", \"arm64\") - Target architecture. If empty, `runtime.GOARCH` is used."
          }
        }
      },
      "UpdateInfo": {
        "id": "type:UpdateInfo",
        "definition": "type UpdateInfo struct {\n    CurrentVersion string\n    LatestVersion  string\n    DownloadURL    string\n    AssetName      string\n    ReleaseNotes   string\n}",
        "purpose": "Contains detailed information about an available update, returned by `CheckAndPrepareUpdate`.",
        "related": {
          "methods": [
            "method:CheckAndPrepareUpdate"
          ],
          "patterns": []
        },
        "interfaceContract": {
          "requiredMethods": [],
          "optionalMethods": [],
          "parameterObjectStructures": {
            "CurrentVersion": "string (e.g., \"v1.0.0\") - The version of the currently running application.",
            "LatestVersion": "string (e.g., \"v1.0.1\") - The semantic version of the latest available release on GitHub.",
            "DownloadURL": "string (URL) - The direct URL to download the update asset.",
            "AssetName": "string - The name of the update asset on GitHub (e.g., \"my-app-v1.0.1-linux-amd64\").",
            "ReleaseNotes": "string - The body/description of the latest GitHub release, often containing changelog information."
          }
        }
      },
      "GitHubAsset": {
        "id": "type:GitHubAsset",
        "definition": "type GitHubAsset struct {\n    Name               string `json:\"name\"`\n    BrowserDownloadURL string `json:\"browser_download_url\"`\n    Size               int64  `json:\"size\"`\n}",
        "purpose": "Internal struct representing a GitHub release asset, used during API calls.",
        "related": {
          "methods": [],
          "patterns": []
        },
        "interfaceContract": {
          "requiredMethods": [],
          "optionalMethods": [],
          "parameterObjectStructures": {
            "Name": "string - Name of the asset as displayed on GitHub.",
            "BrowserDownloadURL": "string - URL to download the asset.",
            "Size": "int64 - Size of the asset in bytes."
          }
        }
      },
      "GitHubRelease": {
        "id": "type:GitHubRelease",
        "definition": "type GitHubRelease struct {\n    TagName    string        `json:\"tag_name\"`\n    Name       string        `json:\"name\"`\n    Body       string        `json:\"body\"`\n    Draft      bool          `json:\"draft\"`\n    Prerelease bool          `json:\"prerelease\"`\n    Assets     []GitHubAsset `json:\"assets\"`\n}",
        "purpose": "Internal struct representing a GitHub release, used during API calls.",
        "related": {
          "methods": [],
          "patterns": []
        },
        "interfaceContract": {
          "requiredMethods": [],
          "optionalMethods": [],
          "parameterObjectStructures": {
            "TagName": "string - The Git tag associated with the release (e.g., \"v1.0.0\").",
            "Name": "string - The name of the release.",
            "Body": "string - The release notes/description.",
            "Draft": "bool - True if the release is a draft.",
            "Prerelease": "bool - True if the release is a pre-release.",
            "Assets": "array of GitHubAsset - List of assets attached to this release."
          }
        }
      }
    },
    "methods": {
      "CheckAndPrepareUpdate": {
        "id": "method:CheckAndPrepareUpdate",
        "useCase": "To check for an available update on GitHub and, if found, download the appropriate binary to a temporary location, making it ready for application.",
        "signature": "func CheckAndPrepareUpdate(config UpdateConfig) (*UpdateInfo, error)",
        "parameters": "config: (type: UpdateConfig) Configuration settings for the update process, including GitHub repository details, current version, data directory, executable path, and asset pattern.",
        "prerequisites": "1. A valid `UpdateConfig` must be provided, with all required fields (GitHubOwner, GitHubRepo, CurrentVersion, DataDir, ExecutablePath, AssetPattern) populated. 2. Network connectivity to GitHub API. 3. The `DataDir` must be writable by the application.",
        "sideEffects": "1. Makes HTTP requests to GitHub API. 2. Downloads a new executable file to the `DataDir` if an update is found. 3. Sets executable permissions (0755) on the downloaded file on Unix-like systems.",
        "returnValue": "A pointer to an `UpdateInfo` struct if a newer version is found and successfully prepared. `nil` if no update is available. An `error` is returned if any step fails (e.g., invalid config, network issues, no matching asset, download failure).",
        "exceptions": [
          "fmt.Errorf(\"invalid config: %w\") - If UpdateConfig fails validation.",
          "fmt.Errorf(\"failed to fetch latest release: %w\") - If GitHub API call fails or returns non-OK status.",
          "fmt.Errorf(\"failed to find matching asset: %w\") - If no asset matching `AssetPattern` is found in the latest release.",
          "fmt.Errorf(\"failed to download update: %w\") - If asset download fails.",
          "fmt.Errorf(\"failed to make update executable: %w\") - If setting file permissions fails on Unix systems."
        ],
        "availability": "sync",
        "status": "active",
        "related": {
          "types": [
            "type:UpdateConfig",
            "type:UpdateInfo"
          ],
          "patterns": [],
          "errors": []
        }
      },
      "ApplyUpdate": {
        "id": "method:ApplyUpdate",
        "useCase": "To initiate the self-replacement process after a new update binary has been prepared by `CheckAndPrepareUpdate`. This function is intended to be the last call in the current application's lifecycle if an update is to be applied.",
        "signature": "func ApplyUpdate(config UpdateConfig) error",
        "parameters": "config: (type: UpdateConfig) The same configuration used for `CheckAndPrepareUpdate`, especially `DataDir` (where the new binary is) and `ExecutablePath` (where the new binary should be copied to).",
        "prerequisites": "1. `CheckAndPrepareUpdate` must have been successfully called, and the new update executable must exist at `filepath.Join(config.DataDir, \"update\"+getExecutableExtension())`. 2. The operating system must allow spawning new processes.",
        "sideEffects": "1. Spawns a new child process (the downloaded update executable). 2. Passes arguments to the new process instructing it to perform the file replacement and then continue normal execution. 3. Calls `os.Exit(0)` in the current process, terminating the old application.",
        "returnValue": "An `error` if the update file is not found or the new process cannot be started. On successful initiation, this function calls `os.Exit(0)` and does not return.",
        "exceptions": [
          "fmt.Errorf(\"no prepared update found at %s\") - If the downloaded update file is missing.",
          "fmt.Errorf(\"failed to start update process: %w\") - If the operating system fails to execute the new binary."
        ],
        "availability": "sync",
        "status": "active",
        "related": {
          "types": [
            "type:UpdateConfig"
          ],
          "patterns": [],
          "errors": []
        }
      },
      "CleanupUpdate": {
        "id": "method:CleanupUpdate",
        "useCase": "To remove any leftover temporary update files (e.g., `update.exe` or `update`) from the designated data directory. This should be called at application startup to ensure a clean state.",
        "signature": "func CleanupUpdate(dataDir string) error",
        "parameters": "dataDir: (type: string) The absolute path to the directory where temporary update files are stored (same as `UpdateConfig.DataDir`).",
        "prerequisites": "The `dataDir` must exist and be writable by the application.",
        "sideEffects": "Deletes the temporary update executable file from the specified directory if it exists.",
        "returnValue": "Returns `nil` if no update file is found or if cleanup is successful. Returns an `error` if the cleanup operation fails (e.g., permission issues during deletion).",
        "exceptions": [
          "fmt.Errorf(\"failed to cleanup update file: %w\") - If `os.Remove` fails due to permissions or other issues."
        ],
        "availability": "sync",
        "status": "active",
        "related": {
          "types": [],
          "patterns": [],
          "errors": []
        }
      },
      "HandleUpdateMode": {
        "id": "method:HandleUpdateMode",
        "useCase": "This critical function must be called as the very first operation in your application's `main` function. It detects if the application was launched by `ApplyUpdate` to perform an in-place update. If so, it takes over, waits for the original process to exit, replaces the old executable with itself, and then allows the application to continue running normally (now as the new version).",
        "signature": "func HandleUpdateMode() bool",
        "parameters": "None.",
        "prerequisites": "This function expects specific command-line arguments (`--perform-update`, `--original-path`, `--pid`) to be passed by the `ApplyUpdate` function.",
        "sideEffects": "1. May wait for a specified process (the old application) to exit. 2. Copies the currently running executable (the new version) over another file (the original executable path). 3. May call `os.Exit(1)` if critical errors occur during the update handling (e.g., invalid arguments, failure to wait for PID, failure to copy file).",
        "returnValue": "Returns `true` if the application was in update mode and successfully completed the self-replacement, indicating that the application should continue with its normal flow as the updated version. Returns `false` if the application was not launched in update mode.",
        "exceptions": [
          "Calls `os.Exit(1)` directly (without returning error) if there are invalid update mode arguments, failure to wait for the old process, or failure to copy the file. This is because the process is in a critical state to complete the update or fail immediately."
        ],
        "availability": "sync",
        "status": "active",
        "related": {
          "types": [],
          "patterns": [],
          "errors": []
        }
      }
    },
    "decisionTrees": {
      "update_flow_decision": {
        "id": "decisionTree:update_flow_decision",
        "question": "Should the application check for and apply an update?",
        "logic": "IF application_starts_in_update_mode THEN execute_file_replacement ELSE IF CheckAndPrepareUpdate_returns_update THEN apply_update ELSE continue_normal_operation",
        "validationMethod": "Observe application version after potential update and check `DataDir` for temporary files.",
        "related": {
          "methods": [
            "method:HandleUpdateMode",
            "method:CheckAndPrepareUpdate",
            "method:ApplyUpdate",
            "method:CleanupUpdate"
          ],
          "patterns": [
            "pattern:basic_update_integration"
          ]
        }
      }
    },
    "patterns": {
      "basic_update_integration": {
        "id": "pattern:basic_update_integration",
        "description": "The fundamental pattern for integrating `ghupdate` into a Go application, ensuring correct handling of update logic at startup and during regular operation.",
        "example": {
          "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"github.com/asaidimu/ghupdate\"\n)\n\nvar Version = \"v1.0.0\" // Injected via ldflags\n\nconst (\n\tgithubOwner  = \"your-owner\"\n\tgithubRepo   = \"your-repo\"\n\tappName      = \"your-app\"\n\tassetPattern = \"{appname}-{version}-{os}-{arch}{ext}\" // Adapt to your naming\n)\n\nfunc main() {\n\t// Phase 1: Handle self-replacement if launched by ApplyUpdate\n\tif ghupdate.HandleUpdateMode() {\n\t\tfmt.Println(\"ðŸŽ‰ Update applied successfully! Resuming.\")\n\t}\n\n\t// Phase 2: Determine data directory and clean up old temp files\n\tdataDir, err := os.UserCacheDir() // Or os.UserConfigDir()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error getting cache dir: %v\", err)\n\t}\n\tappDataDir := filepath.Join(dataDir, appName)\n\tif err := os.MkdirAll(appDataDir, 0755); err != nil {\n\t\tlog.Fatalf(\"Error creating app data dir: %v\", err)\n\t}\n\tif err := ghupdate.CleanupUpdate(appDataDir); err != nil {\n\t\tlog.Printf(\"Warning: Failed to clean up old update files: %v\\n\", err)\n\t}\n\n\t// Phase 3: Your application's core logic\n\tfmt.Printf(\"Running %s version %s\\n\", appName, Version)\n\t// Simulate work\n\t// time.Sleep(2 * time.Second)\n\n\t// Phase 4: Check for and apply updates (e.g., on startup or user command)\n\texecutablePath, err := os.Executable()\n\tif err != nil {\n\t\tlog.Printf(\"Error getting executable path: %v\", err)\n\t\treturn\n\t}\n\n\tconfig := ghupdate.UpdateConfig{\n\t\tGitHubOwner:    githubOwner,\n\t\tGitHubRepo:     githubRepo,\n\t\tGitHubToken:    os.Getenv(\"GITHUB_TOKEN\"), // Optional for public repos\n\t\tCurrentVersion: Version,\n\t\tDataDir:        appDataDir,\n\t\tExecutablePath: executablePath,\n\t\tAssetPattern:   assetPattern,\n\t}\n\n\tupdateInfo, err := ghupdate.CheckAndPrepareUpdate(config)\n\tif err != nil {\n\t\tlog.Printf(\"Error checking for update: %v\\n\", err)\n\t\treturn\n\t}\n\n\tif updateInfo == nil {\n\t\tfmt.Println(\"No update available.\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Update available: %s -> %s\\n\", updateInfo.CurrentVersion, updateInfo.LatestVersion)\n\tif err := ghupdate.ApplyUpdate(config); err != nil {\n\t\tlog.Fatalf(\"Error applying update: %v\\n\", err)\n\t}\n\t// The program exits here if ApplyUpdate succeeds.\n}\n",
          "validation": "The application runs the latest version after the update cycle. No temporary update files remain in `DataDir` after startup. The application restarts automatically to the new version without user intervention."
        },
        "related": {
          "methods": [
            "method:HandleUpdateMode",
            "method:CleanupUpdate",
            "method:CheckAndPrepareUpdate",
            "method:ApplyUpdate"
          ],
          "errors": []
        }
      }
    },
    "errors": {
      "UpdateConfigurationError": {
        "id": "error:UpdateConfigurationError",
        "type": "error (Go error interface)",
        "symptoms": "Application exits with a fatal log message, or `CheckAndPrepareUpdate` returns an error with a message like 'invalid config: GitHubOwner is required'.",
        "properties": "The error object itself might not have specific properties beyond the string message, but the message will indicate which configuration field is missing or invalid.",
        "scenarios": [
          {
            "trigger": "`UpdateConfig.GitHubOwner` is empty.",
            "example": "```go\nconfig := ghupdate.UpdateConfig{\n    // Missing GitHubOwner\n    GitHubRepo: \"my-repo\",\n    CurrentVersion: \"v1.0.0\",\n    DataDir: \"/tmp/data\",\n    ExecutablePath: \"/path/to/app\",\n    AssetPattern: \"app-{version}-{os}-{arch}{ext}\",\n}\n_, err := ghupdate.CheckAndPrepareUpdate(config)\n// err will contain \"invalid config: GitHubOwner is required\"\n```",
            "reason": "`validateConfig` function within `ghupdate` checks for mandatory fields and returns an error if any are missing."
          },
          {
            "trigger": "`UpdateConfig.AssetPattern` is empty.",
            "example": "```go\nconfig := ghupdate.UpdateConfig{\n    GitHubOwner: \"my-owner\",\n    GitHubRepo: \"my-repo\",\n    CurrentVersion: \"v1.0.0\",\n    DataDir: \"/tmp/data\",\n    ExecutablePath: \"/path/to/app\",\n    // Missing AssetPattern\n}\n_, err := ghupdate.CheckAndPrepareUpdate(config)\n// err will contain \"invalid config: AssetPattern is required\"\n```",
            "reason": "`validateConfig` function requires all essential fields to be present to identify and download assets."
          }
        ],
        "diagnosis": "Check the `UpdateConfig` struct initialization. Ensure all fields marked as 'required' in the documentation for `type:UpdateConfig` are populated with non-empty string values. Inspect the error message for the specific missing field.",
        "resolution": "Populate all required fields in the `UpdateConfig` struct before passing it to `CheckAndPrepareUpdate`.",
        "prevention": "Implement robust validation for your application's own configuration inputs that feed into `UpdateConfig`. Use constants for `GitHubOwner`, `GitHubRepo`, `AssetPattern` where possible.",
        "handlingPatterns": "Catch the error from `CheckAndPrepareUpdate` and log it, providing a user-friendly message about setup issues. The application should continue operating without update functionality, or exit gracefully if updates are mandatory for its operation.",
        "propagationBehavior": "Errors of this type are typically returned directly by `CheckAndPrepareUpdate` to the caller, allowing the application to handle them. They do not propagate through other `ghupdate` functions."
      },
      "GitHubAPIError": {
        "id": "error:GitHubAPIError",
        "type": "error (Go error interface)",
        "symptoms": "`CheckAndPrepareUpdate` returns an error containing messages like 'GitHub API returned status 403', 'failed to fetch latest release', 'failed to download from ... failed with status 404', or 'failed to decode GitHub release JSON'.",
        "properties": "The error object will typically wrap the underlying network or HTTP error, or directly contain the HTTP status code in its message.",
        "scenarios": [
          {
            "trigger": "GitHub API rate limit exceeded for unauthenticated requests, or incorrect `GitHubToken` for a private repository.",
            "example": "```go\nconfig := ghupdate.UpdateConfig{ /* ... */ GitHubToken: \"\"} // No token\n// After many requests, CheckAndPrepareUpdate might return:\n// \"GitHub API returned status 403 for https://api.github.com/repos/owner/repo/releases/latest\"\n```",
            "reason": "GitHub imposes rate limits. Unauthenticated requests are severely limited. Private repositories require authentication."
          },
          {
            "trigger": "The specified `GitHubRepo` or `GitHubOwner` does not exist, or the release asset URL is invalid/missing.",
            "example": "```go\nconfig := ghupdate.UpdateConfig{GitHubRepo: \"non-existent-repo\"} // Typo\n// CheckAndPrepareUpdate might return:\n// \"GitHub API returned status 404 for https://api.github.com/repos/owner/non-existent-repo/releases/latest\"\n```",
            "reason": "The HTTP GET request to GitHub's API for releases/latest or asset download returns a 404 Not Found or similar status code, indicating the resource could not be found."
          }
        ],
        "diagnosis": "Verify GitHub owner and repository names in `UpdateConfig`. Ensure the `GitHubToken` (if used) is valid and has appropriate permissions. Check network connectivity. Review GitHub's API status page for outages. For 404 errors during download, ensure the `AssetPattern` correctly matches an existing asset in the latest release.",
        "resolution": "Provide a valid `GitHubToken` for private repos or to bypass rate limits. Correct any typos in `GitHubOwner` or `GitHubRepo`. Adjust `AssetPattern` if it leads to incorrect asset URLs. Retry after a delay if it's a rate limit issue.",
        "prevention": "Always use a `GitHubToken` for production deployments. Implement exponential backoff for retries on API errors. Validate `GitHubOwner` and `GitHubRepo` strings at application startup.",
        "handlingPatterns": "Log these errors but allow the application to continue running without updating. Inform the user that an update check failed. Avoid `log.Fatalf` for these, as they are not necessarily critical to the primary function of the application.",
        "propagationBehavior": "Returned by `CheckAndPrepareUpdate`. These errors do not directly propagate to `ApplyUpdate` unless `CheckAndPrepareUpdate` succeeds in downloading an invalid file that then causes `ApplyUpdate` to fail (less common)."
      },
      "UpdateFileOperationError": {
        "id": "error:UpdateFileOperationError",
        "type": "error (Go error interface)",
        "symptoms": "`CheckAndPrepareUpdate` returns errors like 'failed to make update executable', `ApplyUpdate` returns 'no prepared update found' or 'failed to start update process', `CleanupUpdate` returns 'failed to cleanup update file', or `HandleUpdateMode` exits with a fatal message like 'Failed to replace original executable'.",
        "properties": "The error object will often wrap an underlying `os.PathError` or `syscall.Errno`, providing details about the specific file operation (open, create, chmod, remove, copy) and the path involved.",
        "scenarios": [
          {
            "trigger": "Application lacks write permissions to `DataDir` or `ExecutablePath`.",
            "example": "```go\n// Assume appDataDir is a read-only directory\nif err := ghupdate.CleanupUpdate(appDataDir); err != nil {\n    // err will be similar to \"failed to cleanup update file: remove /read/only/dir/update.exe: permission denied\"\n}\n```",
            "reason": "The operating system prevents the application from performing file system operations (write, delete, change permissions) due to insufficient user privileges in the target directories."
          },
          {
            "trigger": "The `DataDir` specified in `UpdateConfig` does not exist or is inaccessible for writing.",
            "example": "```go\nconfig := ghupdate.UpdateConfig{DataDir: \"/non/existent/path\"}\n_, err := ghupdate.CheckAndPrepareUpdate(config)\n// err will contain \"failed to download update: failed to create directory for \\\"/non/existent/path/update.exe\\\": mkdir /non/existent/path: no such file or directory\"\n```",
            "reason": "The application cannot create the necessary directories or files for storing the downloaded update."
          }
        ],
        "diagnosis": "Check file system permissions for the `DataDir` and `ExecutablePath`. Ensure these directories are user-writable. On Windows, check if the executable is running from a protected location (e.g., Program Files) where user accounts typically don't have write access. On Unix, ensure the executable has necessary permissions or is installed in a user's home directory.",
        "resolution": "Set `DataDir` to a path like `os.UserCacheDir()` or `os.UserConfigDir()`. If the application must reside in a privileged location, consider requiring elevated privileges for the update process, or guide users to install it in their user-specific bin directory. For `HandleUpdateMode` errors, ensure the original application process has truly exited before the new one attempts to copy itself.",
        "prevention": "Always use `os.UserCacheDir()` or `os.UserConfigDir()` for temporary files. Document installation recommendations for users to place the application in user-writable paths.",
        "handlingPatterns": "Log these errors as critical, as they prevent the core update functionality. For `ApplyUpdate` and `HandleUpdateMode` failures, consider calling `os.Exit(1)` to indicate a critical failure. For `CleanupUpdate` and `CheckAndPrepareUpdate` download failures, log a warning and continue, but inform the user that automatic updates might not work.",
        "propagationBehavior": "These errors are generally returned directly by the specific `ghupdate` function (`CheckAndPrepareUpdate`, `ApplyUpdate`, `CleanupUpdate`). `HandleUpdateMode` directly calls `os.Exit(1)` on its failures."
      }
    }
  }
}